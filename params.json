{"name":"Hero","tagline":"Saving projects from role based authorization","body":"# Hero <a href=\"http://skookum.cloudapp.net/viewType.html?buildTypeId=bt8&guest=1\"><img src=\"http://skookum.cloudapp.net/app/rest/builds/buildType:(id:bt8)/statusIcon\"/></a>\r\n\r\n## Server Side\r\nHero is an ability based authorization for .NET MVC and WepAPI projects inspired by the Rails project [CanCan](https://github.com/ryanb/cancan) and by [Derick Bailey](http://lostechies.com/derickbailey/2011/05/24/dont-do-role-based-authorization-checks-do-activity-based-checks/).  Ability based authorization provides a more flexible approach to the traditional .NET authorization technique by decoupling the permissions and code.  By associating a role to a method or action in .NET (through typical Authorization attribute) you are creating a tight coupling between a role and an action.  However, what happens when your role name changes?  Now you have to update all code that references that role name.  By assigning ability names to an action or method you abstract the functionality and the association can be done programmatically.  This allows for a loose coupling of functionality to roles and users.\r\n\r\n## Client Side\r\nIn addition to a server side component, Hero has a Javascript component as well.  The client side version of Hero allows for the injection of security authorization into javascript functions through AOP techniques.\r\n\r\n## HeroAdmin\r\n\r\nHeroAdmin is a client side application that is available to any Hero install by default. It allows users, roles, and abilities to be managed via a web interface. By default it uses an in memory repository for persistence, but can be configured to use any persistence layer you like.\r\n\r\n# Installation\r\n\r\nYou can install this module via [NuGet](http://www.nuget.org). Currently what exists in master is automatically pushed out as a NuGet package. Once Hero becomes more stable, this will change.  Hero can be installed via the following command:\r\n\r\n````\r\nInstall-Package Hero\r\n````\r\n\r\n# Getting Started\r\n\r\nYou will need to include the following code in your BundleConfig.cs in order to access the client side capabilities. If you do not need client side functionality you can skip this step.\r\n\r\n````csharp\r\nbundles.Add(new ScriptBundle(\"~/bundles/herojs\").Include(\r\n            \"~/Scripts/angular.js\",\r\n            \"~/Scripts/angular-resource.js\",\r\n            \"~/Scripts/lodash.js\",\r\n            \"~/Scripts/restangular.js\",\r\n            \"~/Scripts/hero.js\",\r\n            \"~/Scripts/hero-user.js\",\r\n            \"~/Scripts/hero-role.js\",\r\n            \"~/Scripts/hero-ability.js\",\r\n            \"~/Scripts/hero-authorization.js\"));\r\n````\r\n\r\nAdd the following to any page you wish to leverage the client side capabilities.\r\n\r\n````html\r\n@Scripts.Render(\"~/bundles/herojs\")\r\n````\r\n\r\nSee the [server side examples](#server-side-1) below for how to configure your ability based authorization on the server side.\r\n\r\n# Dependencies\r\n\r\nHero currently depends on the following (these are installed automatically if you install via NuGet):\r\n\r\n+ [angular.js](http://angularjs.org/)\r\n+ [dotnetrepositories](https://github.com/Skookum/dotnetrepositories)\r\n+ [dotnetstandard](https://github.com/Skookum/dotnetstandard)\r\n+ [Twitter Bootstrap](http://twitter.github.io/bootstrap/) (for HeroAdmin)\r\n\r\n# Roadmap\r\n\r\n1. Create a provider/adapter to allow Hero to pull user and roles from .NET's built in user and role repositories.\r\n2. Make it easier to create user/role/ability combos in the Global.asax.cs\r\n3. Have a mechanism for allowing auto creation of abilities (for example in a simple CRUD application).\r\n4. Look for methods of hooking the server side registrations to the client side automatically.  This may be through naming conventions or making the function registrations go through the server.\r\n\r\n# Examples\r\n\r\nYou can see a fully implemented example at the [HeroGame](https://github.com/Skookum/HeroGame) project.  For quick help on the server side implementation or client side, see below:\r\n\r\n\r\n##Server Side\r\nThe steps to create user, roles, and register abilities are extremely simple and easy to configure.  This code will typically be performed in the Global.asax or similiar application startup code.\r\n\r\nThe first step is to initialize the authorization services with Hero.\r\n\r\n````csharp\r\nIAbilityAuthorizationService service = new AbilityAuthorizationService();\r\nHeroConfig.Initialize(service);\r\n````\r\n\r\nOnce you have registered a service with Hero the next step is to create an ability.  The following code will create an ability named View.\r\n\r\n````csharp \r\nAbility viewAbility = new Ability(\"View\");\r\nservice.AddAbility(viewAbility);\r\n````\r\n\r\nOnce you have added abilities you can then add roles into the system.\r\n\r\n````csharp \r\nRole basicRole = new Role(\"Basic\");\r\nbasicRole.Abilities.Add(viewAbility);\r\nservice.AddRole(basicRole);\r\n````\r\n\r\nFinally you can add users into the system. Note you can only grant users abilities by adding roles that contain those abilities. You should not add abilities to users directly.\r\n\r\n````csharp \r\nUser basicUser = new User(\"BasicUser\");\r\nbasicUser.Roles.Add(basicRole);\r\nservice.AddUser(basicUser);\r\n````\r\n\r\nOnce you have created the service and added your roles/users with their abilitites you need to associate an action or method with an ability.  This can be performed through the attributes provided in the Hero.Attributes project.  Hero provides an attribute to be utilized in an ASP.NET MVC or WebAPI project.  Abilities can be registered at the controller or action level.  Your more restrictive abilities should be registered at the action level, while the less restrictive should be applied at the controller level.  In the following example, the View ability is the least restrictive, and Create, Edit, and Delete are at the action level.  The view actions (Index and Details) inherit their abilities from the controller level.\r\n\r\nThe corresponding Attribute for WebAPI projects is AbilityWebApiAuthorization.\r\n\r\n````csharp\r\n[AbilityMvcAuthorization(Ability = \"View\")]\r\npublic class ToDoController : Controller\r\n{\r\n    private ToDoDbContext db = new ToDoDbContext();\r\n\r\n    //\r\n    // GET: /ToDo/\r\n\r\n    public ActionResult Index()\r\n    {\r\n        return View(db.Items.ToList());\r\n    }\r\n\r\n    //\r\n    // GET: /ToDo/Details/5\r\n\r\n    public ActionResult Details(int id = 0)\r\n    {\r\n        ToDo todo = db.Items.Find(id);\r\n        if (todo == null)\r\n        {\r\n            return HttpNotFound();\r\n        }\r\n        return View(todo);\r\n    }\r\n\r\n    //\r\n    // GET: /ToDo/Create\r\n\r\n    [AbilityMvcAuthorization(Ability = \"Create\")]\r\n    public ActionResult Create()\r\n    {\r\n        return View();\r\n    }\r\n\r\n    //\r\n    // POST: /ToDo/Create\r\n\r\n    [HttpPost]\r\n    [ValidateAntiForgeryToken]\r\n    [AbilityMvcAuthorization(Ability = \"Create\")]\r\n    public ActionResult Create(ToDo todo)\r\n    {\r\n        if (ModelState.IsValid)\r\n        {\r\n            db.Items.Add(todo);\r\n            db.SaveChanges();\r\n            return RedirectToAction(\"Index\");\r\n        }\r\n\r\n        return View(todo);\r\n    }\r\n\r\n    //\r\n    // GET: /ToDo/Edit/5\r\n    [AbilityMvcAuthorization(Ability = \"Edit\")]\r\n    public ActionResult Edit(int id = 0)\r\n    {\r\n        ToDo todo = db.Items.Find(id);\r\n        if (todo == null)\r\n        {\r\n            return HttpNotFound();\r\n        }\r\n        return View(todo);\r\n    }\r\n\r\n    //\r\n    // POST: /ToDo/Edit/5\r\n\r\n    [HttpPost]\r\n    [ValidateAntiForgeryToken]\r\n    [AbilityMvcAuthorization(Ability = \"Edit\")]\r\n    public ActionResult Edit(ToDo todo)\r\n    {\r\n        if (ModelState.IsValid)\r\n        {\r\n            db.Entry(todo).State = EntityState.Modified;\r\n            db.SaveChanges();\r\n            return RedirectToAction(\"Index\");\r\n        }\r\n        return View(todo);\r\n    }\r\n\r\n    //\r\n    // GET: /ToDo/Delete/5\r\n    [AbilityMvcAuthorization(Ability = \"Delete\")]\r\n    public ActionResult Delete(int id = 0)\r\n    {\r\n        ToDo todo = db.Items.Find(id);\r\n        if (todo == null)\r\n        {\r\n            return HttpNotFound();\r\n        }\r\n        return View(todo);\r\n    }\r\n\r\n    //\r\n    // POST: /ToDo/Delete/5\r\n\r\n    [HttpPost, ActionName(\"Delete\")]\r\n    [ValidateAntiForgeryToken]\r\n    [AbilityMvcAuthorization(Ability = \"Delete\")]\r\n    public ActionResult DeleteConfirmed(int id)\r\n    {\r\n        ToDo todo = db.Items.Find(id);\r\n        db.Items.Remove(todo);\r\n        db.SaveChanges();\r\n        return RedirectToAction(\"Index\");\r\n    }\r\n\r\n    protected override void Dispose(bool disposing)\r\n    {\r\n        db.Dispose();\r\n        base.Dispose(disposing);\r\n    }\r\n}\r\n````\r\n\r\nFinally you can leverage perform authorization checks in your Razor views\r\n\r\n````csharp\r\n<p>\r\n    @if (HeroConfig.Can(User.Identity.Name, \"Create\"))\r\n    {\r\n        @Html.ActionLink(\"Create New\", \"Create\", null, new {@class = \"createButton\"})\r\n    }\r\n</p>\r\n````\r\n\r\nThis is all it takes to configure you ability based authorization system on the server side. Now your code and your authorization are decoupled. This means you can add new roles, remove roles, rename roles, etc. all from an admin panel instead of redeploying an application.  You can also leverage your registered abilities on the client side as well.  See below for an examples.\r\n\r\n## Complex Abilities\r\n  Another feature Hero provides is an ability hierarchy. This makes Hero more flexible and easier to register users with their appropriate abilities.  The example below creates an ability hierarchy called Manage that contains the Edit, Create, and Delete abilities.  When the manage ability is registered with AdminRole, the Edit, Create, and Delete abilities are also available to the AdminRole.\r\n\r\n````csharp\r\nRole toDoAdminRole = new Role(\"ToDoAdmin\");\r\nRole toDoEditRole = new Role(\"ToDoEdit\");\r\n\r\nAbility toDoCreateAbility = new Ability(\"Create\");\r\nAbility toDoDeleteAbility = new Ability(\"Delete\");\r\nAbility toDoEditContentAbility = new Ability(\"EditContent\");\r\nAbility toDoEditDataAbility = new Ability(\"EditData\");\r\n\r\nAbility toDoEditAbility = new Ability(\"Edit\");\r\ntodoEditAbility.Add(toDoEditContentAbility);\r\ntodoEditAbility.Add(toDoEditDataAbility);\r\n\r\nAbility manageAbility = new Ability(\"Manage\");\r\nmanageAbility.Abilities.Add(toDoCreateAbility);\r\nmanageAbility.Abilities.Add(toDoEditAbility);\r\nmanageAbility.Abilities.Add(toDoDeleteAbility);\r\n\r\ntoDoAdminRole.Abilities.Add(manageAbility);\r\ntoDoEditRole.Abilities.Add(toDoEditAbility);\r\n````\r\n\r\n##Client Side\r\nGenerally speaking providing authorization at the server level is not the entire story.  If a user does not have permission to perform an action, the trigger (button, link, visual container) would not even be visible to a user.  Hero provides a client side implementation to help keep your client ability triggers in sync with the server and provies support for Single Page Applications (SPA).\r\n\r\nThe following code will create a simple javascript module for managing these triggers.  The module has functions for showing the create, edit, delete, and details button utilized in the ToDo HD application.  By default these buttons are hidden and only if the user is authorized will the module functions run.\r\n\r\n````javascript\r\n//Add a module for the buttons on the page.\r\n(function (testModule) {\r\n    var getCreateButton = function() { return document.getElementsByClassName(\"createButton\"); };\r\n    var getDeleteButton = function () { return document.getElementsByClassName(\"deleteButton\"); };\r\n    var getEditButton = function () { return document.getElementsByClassName(\"editButton\"); };\r\n    var getDetailsButton = function () { return document.getElementsByClassName(\"detailsButton\"); };\r\n\r\n    var show = function (elem) {\r\n        if (elem) {\r\n            for (var i = 0; i < elem.length; i++) {\r\n                if (elem[i]) elem[i].style.display = 'inline';\r\n            }\r\n        }\r\n    };\r\n    \r\n    testModule.showCreateButton = function showCreateButton() {\r\n        show(getCreateButton());\r\n    };\r\n    \r\n    testModule.showDeleteButton = function showDeleteButton() {\r\n        show(getDeleteButton());\r\n    };\r\n    \r\n    testModule.showEditButton = function showEditButton() {\r\n        show(getEditButton());\r\n    };\r\n    \r\n    testModule.showDetailsButton = function showDetailsButton() {\r\n        show(getDetailsButton());\r\n    };\r\n    \r\n})(window.TestModule = window.TestModule || {});\r\n\r\n//on doc ready show/hide the buttons.\r\n$(document).ready(function () {\r\n    TestModule.showCreateButton();\r\n    TestModule.showDeleteButton();\r\n    TestModule.showEditButton();\r\n    TestModule.showDetailsButton();\r\n});\r\n\r\n\r\n//initialize the ability based authorization utilizing the Hero project\r\nHero.init()\r\n    .registerAbility(\"View\", TestModule, TestModule.prototype.showDetailsButton)\r\n    .registerAbility(\"Create\", TestModule, TestModule.prototype.showCreateButton)\r\n    .registerAbility(\"Edit\", TestModule, TestModule.prototype.showEditButton)\r\n    .registerAbility(\"Delete\", TestModule, TestModule.prototype.showDeleteButton);\r\n````\r\n\r\nThe configuration code provides a fluent syntax for registering a module's public functions with an Ability.  In the previous example, if the user has the Create ability then the showCreateButton will be allowed to run (and thus the button will become visible).  One point to note here is the endpoint.  Hero installs an Abilities controller by default and your Hero javascript configuration will need to point to this controller.\r\n\r\n## HeroAdmin Usage\r\n\r\nHero also include HeroAdmin. HeroAdmin is an SPA that was built to ease the management task of creating abilities, roles, and users. If you wish to use HeroAdmin in your application you will need to add the following to your BundleConfig.cs\r\n\r\n````csharp\r\nbundles.Add(new StyleBundle(\"~/Content/bootstrap\").Include(\"~/Content/bootstrap.css\"));\r\nbundles.Add(new ScriptBundle(\"~/bundles/herojs\").Include(\r\n            \"~/Scripts/angular.js\",\r\n            \"~/Scripts/angular-resource.js\",\r\n            \"~/Scripts/lodash.js\",\r\n            \"~/Scripts/restangular.js\",\r\n            \"~/Scripts/hero.js\",\r\n            \"~/Scripts/hero-user.js\",\r\n            \"~/Scripts/hero-role.js\",\r\n            \"~/Scripts/hero-ability.js\",\r\n            \"~/Scripts/hero-authorization.js\"));\r\n````\r\n\r\nAdd the following to the page you wish the HeroAdmin console to appear. Typically you can create an Admin MVC controller/view to support this (see HeroGame for example):\r\n\r\n````html\r\n@Scripts.Render(\"~/bundles/herojs\")\r\n@Scripts.Render(\"~/Scripts/init.js\")\r\n\r\n<div id=\"admin-console\"></div>\r\n````\r\n\r\nFinally create an init.js (or similar):\r\n\r\n````javascript\r\n(function () {\r\n  Hero.init().buildConsole();\r\n})();\r\n````\r\nYou should then see the HeroAdmin console.\r\n![HeroAdmin Console](http://i.snag.gy/qqLp1.jpg \"HeroAdmin\")\r\n\r\nNote: if you wish to override the default in memory repositories that Hero uses you can pass in a User,Role, and Ability Repository to the AuthorizationService.\r\n\r\n# Contributing\r\n\r\nSee [CONTRIBUTING.md](CONTRIBUTING.md)\r\n\r\n# License\r\n\r\nThis project is licensed under the [MIT License](http://opensource.org/licenses/MIT)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}